/*  Prim's algorithm

1.  Make a queue (Q) with all the vertices of G (V);
2.  For each member of Q set the priority to INFINITY;
3.  Only for the starting vertex (s) set the priority to 0;
4.  The parent of (s) should be NULL;
5.  While Q isn’t empty
6.     Get the minimum from Q – let’s say (u); (priority queue);
7.     For each adjacent vertex to (v) to (u)
8.        If (v) is in Q and weight of (u, v) < priority of (v) then
9.           The parent of (v) is set to be (u)
10.          The priority of (v) is the weight of (u, v)
*/

TreeMap = class( "java.util.TreeMap" );

INFINITY = 100000000;
 
// the graph

graph = [
	0: [ 0,  4,  0,  0,  0,  0,  0,  0,  8 ],
	1: [ 4,  0,  8,  0,  0,  0,  0,  0, 11 ],
	2: [ 0,  8,  0,  7,  0,  4,  2,  0,  0 ],
	3: [ 0,  0,  7,  0,  9, 14,  0,  0,  0 ],
	4: [ 0,  0,  0,  9,  0, 10,  0,  0,  0 ],
	5: [ 0,  0,  4, 14, 10,  0,  0,  2,  0 ],
	6: [ 0,  0,  2,  0,  0,  0,  0,  6,  7 ],
	7: [ 0,  0,  0,  0,  0,  2,  6,  0,  1 ],
	8: [ 8, 11,  0,  0,  0,  0,  7,  1,  0 ]
];

prim = ( graph, start ) => {
	
	queue = [:];
    parent = [];
 
 	graph.eachKey( k => queue[ k ] = INFINITY );
 
 	queue[ start ] = 0;
 	parent[ start ] = null;
 
 	while( queue; {
 	
        // get the minimum value
        min = INFINITY; minKey = -1;
        queue.each( ( key, value ) => if( value < min; minKey = key, min = value ) );

		graph[ minKey ].each( ( v, weight ) =>
            if( weight > 0 && queue.containsKey( v ) && weight < queue[ v ] ) (
                parent[ v ] = minKey;
                queue[ v ] = weight;
            )
		);
 
 		queue.remove( minKey );
    } );
 
    parent
};
 
println( prim( graph, 5 ) );
